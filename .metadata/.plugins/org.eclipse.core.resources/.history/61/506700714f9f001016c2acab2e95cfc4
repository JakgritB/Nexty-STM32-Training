/*
 * Manual Transmission Car Simulator for STM32F411xE
 * Bare-metal implementation with Timer Interrupt at 100Hz
 *
 * Pin Mapping:
 * - PA5:  Engine LED
 * - PB6:  Wiper LED
 * - PA9, PB10, PA8, PC7: BCD 7-Segment (MSB to LSB)
 * - PA10: Clutch Button (Pull-up, Active Low)
 * - PB3:  Brake Button (Pull-up, Active Low)
 * - PB5:  Gas Button (Pull-up, Active Low)
 * - PB4:  Wiper Button (Pull-up, Active Low)
 * - PA4:  Gear Potentiometer (ADC1 Channel 4)
 * - PA2:  UART TX
 * - PA3:  UART RX (115200 baud)
 */

#include <stdint.h>
#include <stdio.h>
#include <string.h>

/* STM32F411xE Register Definitions */
#define RCC_BASE            0x40023800
#define GPIOA_BASE          0x40020000
#define GPIOB_BASE          0x40020400
#define GPIOC_BASE          0x40020800
#define ADC1_BASE           0x40012000
#define TIM2_BASE           0x40000000
#define USART2_BASE         0x40004400
#define NVIC_BASE           0xE000E100

/* RCC Registers */
#define RCC_AHB1ENR         (*(volatile uint32_t *)(RCC_BASE + 0x30))
#define RCC_APB1ENR         (*(volatile uint32_t *)(RCC_BASE + 0x40))
#define RCC_APB2ENR         (*(volatile uint32_t *)(RCC_BASE + 0x44))

/* GPIO Registers */
typedef struct {
    volatile uint32_t MODER;
    volatile uint32_t OTYPER;
    volatile uint32_t OSPEEDR;
    volatile uint32_t PUPDR;
    volatile uint32_t IDR;
    volatile uint32_t ODR;
    volatile uint32_t BSRR;
    volatile uint32_t LCKR;
    volatile uint32_t AFR[2];
} GPIO_TypeDef;

#define GPIOA ((GPIO_TypeDef *)GPIOA_BASE)
#define GPIOB ((GPIO_TypeDef *)GPIOB_BASE)
#define GPIOC ((GPIO_TypeDef *)GPIOC_BASE)

/* ADC Registers */
typedef struct {
    volatile uint32_t SR;
    volatile uint32_t CR1;
    volatile uint32_t CR2;
    volatile uint32_t SMPR1;
    volatile uint32_t SMPR2;
    volatile uint32_t JOFR[4];
    volatile uint32_t HTR;
    volatile uint32_t LTR;
    volatile uint32_t SQR1;
    volatile uint32_t SQR2;
    volatile uint32_t SQR3;
    volatile uint32_t JSQR;
    volatile uint32_t JDR[4];
    volatile uint32_t DR;
} ADC_TypeDef;

#define ADC1 ((ADC_TypeDef *)ADC1_BASE)
#define ADC_CCR (*(volatile uint32_t *)(ADC1_BASE + 0x304))

/* Timer Registers */
typedef struct {
    volatile uint32_t CR1;
    volatile uint32_t CR2;
    volatile uint32_t SMCR;
    volatile uint32_t DIER;
    volatile uint32_t SR;
    volatile uint32_t EGR;
    volatile uint32_t CCMR1;
    volatile uint32_t CCMR2;
    volatile uint32_t CCER;
    volatile uint32_t CNT;
    volatile uint32_t PSC;
    volatile uint32_t ARR;
    volatile uint32_t RES1;
    volatile uint32_t CCR1;
    volatile uint32_t CCR2;
    volatile uint32_t CCR3;
    volatile uint32_t CCR4;
    volatile uint32_t RES2;
    volatile uint32_t DCR;
    volatile uint32_t DMAR;
} TIM_TypeDef;

#define TIM2 ((TIM_TypeDef *)TIM2_BASE)

/* USART Registers */
typedef struct {
    volatile uint32_t SR;
    volatile uint32_t DR;
    volatile uint32_t BRR;
    volatile uint32_t CR1;
    volatile uint32_t CR2;
    volatile uint32_t CR3;
    volatile uint32_t GTPR;
} USART_TypeDef;

#define USART2 ((USART_TypeDef *)USART2_BASE)

/* NVIC */
#define NVIC_ISER0 (*(volatile uint32_t *)(NVIC_BASE + 0x000))
#define NVIC_ISER1 (*(volatile uint32_t *)(NVIC_BASE + 0x004))

/* System Clock (assuming 100MHz after PLL configuration) */
#define SYSTEM_CLOCK 100000000
#define TIMER_FREQ   100  // 100Hz update rate

/* Driving Modes */
typedef enum {
    MODE_ECO = 0,
    MODE_NORMAL,
    MODE_SPORT
} DrivingMode;

/* Wiper Modes */
typedef enum {
    WIPER_OFF = 0,
    WIPER_SLOW,
    WIPER_MEDIUM,
    WIPER_FAST
} WiperMode;

/* Gear Definition */
typedef enum {
    GEAR_N = 0,
    GEAR_1,
    GEAR_2,
    GEAR_3,
    GEAR_4,
    GEAR_5
} Gear;

/* Speed Ranges for each gear (km/h) */
typedef struct {
    uint8_t min;
    uint8_t max;
} SpeedRange;

const SpeedRange GEAR_SPEEDS[] = {
    {0, 0},     // N
    {0, 30},    // 1
    {20, 50},   // 2
    {40, 70},   // 3
    {40, 90},   // 4
    {80, 130}   // 5
};

/* Acceleration rates (km/h per second) */
#define ACCEL_ECO       10.0f
#define ACCEL_NORMAL    20.0f
#define ACCEL_SPORT     35.0f
#define DECEL_BRAKE     50.0f
#define DECEL_COASTING  5.0f

/* Global volatile variables (shared with interrupts) */
volatile uint8_t engine_running = 0;
volatile float current_speed = 0.0f;
volatile Gear current_gear = GEAR_N;
volatile Gear previous_gear = GEAR_N;
volatile DrivingMode drive_mode = MODE_NORMAL;
volatile WiperMode wiper_mode = WIPER_OFF;

volatile uint8_t clutch_pressed = 0;
volatile uint8_t brake_pressed = 0;
volatile uint8_t gas_pressed = 0;
volatile uint8_t wiper_button_pressed = 0;
volatile uint8_t wiper_button_last = 1;

volatile uint16_t adc_value = 0;
volatile uint16_t wiper_counter = 0;
volatile uint16_t wiper_led_state = 0;
volatile uint16_t uart_send_counter = 0;

/* UART buffer */
volatile char uart_rx_char = 0;
volatile uint8_t uart_rx_flag = 0;

/* Function prototypes */
void SystemInit(void);
void GPIO_Init(void);
void ADC_Init(void);
void USART2_Init(void);
void TIM2_Init(void);
void USART2_SendString(const char *str);
void USART2_SendSpeed(void);
void Update_7Segment(uint8_t value);
void Update_Engine_LED(void);
void Update_Wiper_LED(void);
uint16_t ADC_Read(void);
Gear ADC_to_Gear(uint16_t adc_val);
void Read_Buttons(void);
void Check_Stall_Conditions(void);
void Update_Speed(void);
void Process_UART_Command(char cmd);

/* Main function */
int main(void) {
    SystemInit();
    GPIO_Init();
    ADC_Init();
    USART2_Init();
    TIM2_Init();

    USART2_SendString("Manual Transmission Car Simulator\r\n");
    USART2_SendString("Commands: o=start, f=stop, e=eco, n=normal, s=sport\r\n");

    while (1) {
        // Main loop: process UART commands
        if (uart_rx_flag) {
            uart_rx_flag = 0;
            Process_UART_Command(uart_rx_char);
        }
    }
}

/* System initialization (basic clock setup) */
void SystemInit(void) {
    // Enable FPU
    *(volatile uint32_t *)0xE000ED88 |= (0xF << 20);

    // For simplicity, we assume HSI (16MHz) is used
    // In real application, configure PLL for higher frequency
}

/* GPIO initialization */
void GPIO_Init(void) {
    // Enable GPIO clocks
    RCC_AHB1ENR |= (1 << 0) | (1 << 1) | (1 << 2); // GPIOA, GPIOB, GPIOC

    /* Output pins */
    // PA5: Engine LED (Output)
    GPIOA->MODER &= ~(3 << (5*2));
    GPIOA->MODER |= (1 << (5*2));

    // PB6: Wiper LED (Output)
    GPIOB->MODER &= ~(3 << (6*2));
    GPIOB->MODER |= (1 << (6*2));

    // BCD outputs: PA9, PB10, PA8, PC7 (MSB to LSB)
    GPIOA->MODER &= ~((3 << (9*2)) | (3 << (8*2)));
    GPIOA->MODER |= (1 << (9*2)) | (1 << (8*2));

    GPIOB->MODER &= ~(3 << (10*2));
    GPIOB->MODER |= (1 << (10*2));

    GPIOC->MODER &= ~(3 << (7*2));
    GPIOC->MODER |= (1 << (7*2));

    /* Input pins with pull-up */
    // PA10: Clutch (Input, Pull-up)
    GPIOA->MODER &= ~(3 << (10*2));
    GPIOA->PUPDR &= ~(3 << (10*2));
    GPIOA->PUPDR |= (1 << (10*2));

    // PB3: Brake (Input, Pull-up)
    GPIOB->MODER &= ~(3 << (3*2));
    GPIOB->PUPDR &= ~(3 << (3*2));
    GPIOB->PUPDR |= (1 << (3*2));

    // PB5: Gas (Input, Pull-up)
    GPIOB->MODER &= ~(3 << (5*2));
    GPIOB->PUPDR &= ~(3 << (5*2));
    GPIOB->PUPDR |= (1 << (5*2));

    // PB4: Wiper (Input, Pull-up)
    GPIOB->MODER &= ~(3 << (4*2));
    GPIOB->PUPDR &= ~(3 << (4*2));
    GPIOB->PUPDR |= (1 << (4*2));

    // PA4: ADC (Analog mode)
    GPIOA->MODER |= (3 << (4*2));

    // USART2 pins (PA2=TX, PA3=RX, AF7)
    GPIOA->MODER &= ~((3 << (2*2)) | (3 << (3*2)));
    GPIOA->MODER |= (2 << (2*2)) | (2 << (3*2));
    GPIOA->AFR[0] &= ~((0xF << (2*4)) | (0xF << (3*4)));
    GPIOA->AFR[0] |= (7 << (2*4)) | (7 << (3*4));
}

/* ADC initialization */
void ADC_Init(void) {
    RCC_APB2ENR |= (1 << 8); // Enable ADC1 clock

    // ADC configuration
    ADC1->CR2 = 0;
    ADC1->CR1 = 0;

    // Sampling time for channel 4 (PA4): 84 cycles
    ADC1->SMPR2 |= (4 << (4*3));

    // Regular sequence: 1 conversion, channel 4
    ADC1->SQR1 = 0; // 1 conversion
    ADC1->SQR3 = 4; // Channel 4

    // Enable ADC
    ADC1->CR2 |= (1 << 0); // ADON
}

/* USART2 initialization (115200 baud) */
void USART2_Init(void) {
    RCC_APB1ENR |= (1 << 17); // Enable USART2 clock

    // Baud rate: 115200 (assuming 16MHz APB1 clock)
    // BRR = 16MHz / 115200 â‰ˆ 139 (0x8B)
    USART2->BRR = 139;

    // Enable USART, TX, RX, and RXNE interrupt
    USART2->CR1 = (1 << 13) | (1 << 3) | (1 << 2) | (1 << 5);

    // Enable USART2 interrupt in NVIC
    NVIC_ISER1 |= (1 << (38 - 32)); // USART2 is IRQ 38
}

/* Timer 2 initialization (100Hz) */
void TIM2_Init(void) {
    RCC_APB1ENR |= (1 << 0); // Enable TIM2 clock

    // TIM2 runs at APB1 clock (16MHz assumed)
    // Prescaler: 16000-1 (1ms tick)
    // Auto-reload: 10-1 (10ms = 100Hz)
    TIM2->PSC = 16000 - 1;
    TIM2->ARR = 10 - 1;

    // Enable update interrupt
    TIM2->DIER |= (1 << 0);

    // Enable TIM2 interrupt in NVIC (IRQ 28)
    NVIC_ISER0 |= (1 << 28);

    // Start timer
    TIM2->CR1 |= (1 << 0);
}

/* TIM2 interrupt handler (100Hz heartbeat) */
void TIM2_IRQHandler(void) {
    if (TIM2->SR & (1 << 0)) {
        TIM2->SR &= ~(1 << 0); // Clear interrupt flag

        // Read ADC and determine gear
        adc_value = ADC_Read();
        previous_gear = current_gear;
        current_gear = ADC_to_Gear(adc_value);

        // Read button states
        Read_Buttons();

        // Update 7-segment display
        Update_7Segment(current_gear);

        // Check stall conditions
        Check_Stall_Conditions();

        // Update speed based on inputs
        Update_Speed();

        // Update LEDs
        Update_Engine_LED();
        Update_Wiper_LED();

        // Send speed via UART every 500ms (50 timer ticks)
        uart_send_counter++;
        if (uart_send_counter >= 50) {
            uart_send_counter = 0;
            USART2_SendSpeed();
        }
    }
}

/* USART2 interrupt handler */
void USART2_IRQHandler(void) {
    if (USART2->SR & (1 << 5)) { // RXNE flag
        uart_rx_char = USART2->DR;
        uart_rx_flag = 1;
    }
}

/* Read ADC value */
uint16_t ADC_Read(void) {
    ADC1->CR2 |= (1 << 30); // Start conversion
    while (!(ADC1->SR & (1 << 1))); // Wait for EOC
    return ADC1->DR;
}

/* Convert ADC value to gear */
Gear ADC_to_Gear(uint16_t adc_val) {
    // Divide 0-4095 into 6 equal ranges
    if (adc_val < 683) return GEAR_N;
    else if (adc_val < 1366) return GEAR_1;
    else if (adc_val < 2049) return GEAR_2;
    else if (adc_val < 2732) return GEAR_3;
    else if (adc_val < 3414) return GEAR_4;
    else return GEAR_5;
}

/* Read button states (active low) */
void Read_Buttons(void) {
    clutch_pressed = !(GPIOA->IDR & (1 << 10));
    brake_pressed = !(GPIOB->IDR & (1 << 3));
    gas_pressed = !(GPIOB->IDR & (1 << 5));

    // Wiper button with debouncing
    uint8_t wiper_current = !(GPIOB->IDR & (1 << 4));
    if (wiper_current && !wiper_button_last) {
        // Rising edge detected
        wiper_mode = (wiper_mode + 1) % 4;
        wiper_counter = 0; // Reset wiper counter
    }
    wiper_button_last = wiper_current;
}

/* Check stall conditions */
void Check_Stall_Conditions(void) {
    if (!engine_running) return;

    // Clutchless gear change -> stall
    if (current_gear != previous_gear && !clutch_pressed) {
        engine_running = 0;
        USART2_SendString("Engine stalled: clutchless gear change\r\n");
        return;
    }

    // Gear 1 at speed 0 without gas/clutch -> stall
    if (current_gear == GEAR_1 && current_speed < 0.1f &&
        !gas_pressed && !clutch_pressed) {
        engine_running = 0;
        USART2_SendString("Engine stalled: idle at gear 1\r\n");
        return;
    }

    // Low speed stall (speed below minimum for current gear)
    if (current_gear != GEAR_N && current_gear != GEAR_1) {
        if (current_speed < GEAR_SPEEDS[current_gear].min) {
            engine_running = 0;
            USART2_SendString("Engine stalled: speed too low for gear\r\n");
            return;
        }
    }
}

/* Update speed based on inputs */
void Update_Speed(void) {
    if (!engine_running) {
        current_speed = 0.0f;
        return;
    }

    float accel_rate = 0.0f;

    // Determine acceleration rate based on mode
    switch (drive_mode) {
        case MODE_ECO: accel_rate = ACCEL_ECO; break;
        case MODE_NORMAL: accel_rate = ACCEL_NORMAL; break;
        case MODE_SPORT: accel_rate = ACCEL_SPORT; break;
    }

    // Brake has priority
    if (brake_pressed) {
        current_speed -= DECEL_BRAKE / TIMER_FREQ;
        if (current_speed < 0.0f) current_speed = 0.0f;
        return;
    }

    // Cannot accelerate with clutch pressed (except gear 1 special case)
    if (clutch_pressed) {
        if (current_gear == GEAR_1 && current_speed < 10.0f && gas_pressed) {
            // Special case: Gear 1 + clutch + gas can accelerate to 10 km/h
            current_speed += accel_rate / TIMER_FREQ;
            if (current_speed > 10.0f) current_speed = 10.0f;
        } else {
            // Coasting with clutch
            current_speed -= DECEL_COASTING / TIMER_FREQ;
            if (current_speed < 0.0f) current_speed = 0.0f;
        }
        return;
    }

    // Cannot drive in neutral
    if (current_gear == GEAR_N) {
        current_speed -= DECEL_COASTING / TIMER_FREQ;
        if (current_speed < 0.0f) current_speed = 0.0f;
        return;
    }

    // Accelerate if gas pressed
    if (gas_pressed) {
        current_speed += accel_rate / TIMER_FREQ;

        // Speed limiter: cannot exceed max speed for current gear
        if (current_speed > GEAR_SPEEDS[current_gear].max) {
            current_speed = GEAR_SPEEDS[current_gear].max;
        }
    } else {
        // Coasting (natural deceleration)
        current_speed -= DECEL_COASTING / TIMER_FREQ;
        if (current_speed < 0.0f) current_speed = 0.0f;
    }
}

/* Update 7-segment display (BCD output) */
void Update_7Segment(uint8_t value) {
    // BCD encoding: PA9 (MSB), PB10, PA8, PC7 (LSB)
    // N=0, 1=1, 2=2, 3=3, 4=4, 5=5

    // Clear all BCD pins
    GPIOA->BSRR = (1 << (9+16)) | (1 << (8+16)); // Reset PA9, PA8
    GPIOB->BSRR = (1 << (10+16)); // Reset PB10
    GPIOC->BSRR = (1 << (7+16)); // Reset PC7

    // Set BCD value
    if (value & 0x08) GPIOA->BSRR = (1 << 9);  // MSB
    if (value & 0x04) GPIOB->BSRR = (1 << 10);
    if (value & 0x02) GPIOA->BSRR = (1 << 8);
    if (value & 0x01) GPIOC->BSRR = (1 << 7);  // LSB
}

/* Update engine LED */
void Update_Engine_LED(void) {
    if (engine_running) {
        GPIOA->BSRR = (1 << 5); // Set PA5
    } else {
        GPIOA->BSRR = (1 << (5+16)); // Reset PA5
    }
}

/* Update wiper LED */
void Update_Wiper_LED(void) {
    uint16_t period = 0;

    switch (wiper_mode) {
        case WIPER_OFF:
            GPIOB->BSRR = (1 << (6+16)); // LED off
            return;
        case WIPER_SLOW:
            period = 100; // 1 second (100 ticks at 100Hz)
            break;
        case WIPER_MEDIUM:
            period = 50; // 0.5 second
            break;
        case WIPER_FAST:
            period = 10; // 0.1 second
            break;
    }

    wiper_counter++;
    if (wiper_counter >= period) {
        wiper_counter = 0;
        wiper_led_state = !wiper_led_state;
    }

    if (wiper_led_state) {
        GPIOB->BSRR = (1 << 6); // Set PB6
    } else {
        GPIOB->BSRR = (1 << (6+16)); // Reset PB6
    }
}

/* Process UART commands */
void Process_UART_Command(char cmd) {
    switch (cmd) {
        case 'o':
            if (current_gear == GEAR_N && !engine_running) {
                engine_running = 1;
                USART2_SendString("Engine started\r\n");
            } else {
                USART2_SendString("Cannot start: must be in Neutral\r\n");
            }
            break;
        case 'f':
            engine_running = 0;
            USART2_SendString("Engine stopped\r\n");
            break;
        case 'e':
            drive_mode = MODE_ECO;
            USART2_SendString("Mode: ECO\r\n");
            break;
        case 'n':
            drive_mode = MODE_NORMAL;
            USART2_SendString("Mode: NORMAL\r\n");
            break;
        case 's':
            drive_mode = MODE_SPORT;
            USART2_SendString("Mode: SPORT\r\n");
            break;
        default:
            USART2_SendString("Unknown command\r\n");
            break;
    }
}

/* Send speed via UART */
void USART2_SendSpeed(void) {
    char buffer[32];
    int speed_int = (int)current_speed;

    // Simple integer to string conversion
    buffer[0] = 'S';
    buffer[1] = 'p';
    buffer[2] = 'e';
    buffer[3] = 'e';
    buffer[4] = 'd';
    buffer[5] = ':';
    buffer[6] = ' ';

    int idx = 7;
    if (speed_int == 0) {
        buffer[idx++] = '0';
    } else {
        int temp = speed_int;
        int digits = 0;
        while (temp > 0) {
            temp /= 10;
            digits++;
        }

        for (int i = digits - 1; i >= 0; i--) {
            buffer[idx + i] = '0' + (speed_int % 10);
            speed_int /= 10;
        }
        idx += digits;
    }

    buffer[idx++] = ' ';
    buffer[idx++] = 'k';
    buffer[idx++] = 'm';
    buffer[idx++] = '/';
    buffer[idx++] = 'h';
    buffer[idx++] = '\r';
    buffer[idx++] = '\n';
    buffer[idx] = '\0';

    USART2_SendString(buffer);
}

/* Send string via USART2 */
void USART2_SendString(const char *str) {
    while (*str) {
        while (!(USART2->SR & (1 << 7))); // Wait for TXE
        USART2->DR = *str++;
    }
}
