#include <stdint.h>
#define STM32F411xE
#include "stm32f4xx.h"

volatile uint16_t g_adc_value = 0;

void ADC_IRQHandler(void) {
	if (ADC1->SR & ADC_SR_EOC) {
		g_adc_value = ADC1->DR;
	}
}

int main(void) {
	//Clock
	// GPIO Port A, Port B, ADC1
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN | RCC_AHB1ENR_GPIOBEN;
	RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;

	// PA5, PA6, PA7
	GPIOA->MODER |= (0b01 << GPIO_MODER_MODER5_Pos);
	GPIOA->MODER |= (0b01 << GPIO_MODER_MODER6_Pos);
	GPIOA->MODER |= (0b01 << GPIO_MODER_MODER7_Pos);
	GPIOB->MODER |= (0b01 << GPIO_MODER_MODER6_Pos);

	// PA4 Analog Input
	GPIOA->MODER |= (0b11 << GPIO_MODER_MODER4_Pos);

	ADC1->SQR1 &= ~(ADC_SQR1_L);

	ADC1->SQR3 &= ~(ADC_SQR3_SQ1);
	ADC1->SQR3 |= (4 << ADC_SQR3_SQ1_Pos);

	ADC1->CR2 |= ADC_CR2_CONT;
	ADC1->CR1 |= ADC_CR1_EOCIE;
	ADC1->CR2 |= ADC_CR2_ADON;
	NVIC_EnableIRQ(ADC_IRQn);
	ADC1->CR2 |= ADC_CR2_SWSTART;

	while (1) {
		if (g_adc_value > 3280) {
			GPIOB->ODR &= ~(GPIO_ODR_OD6);
			GPIOA->ODR &= ~(GPIO_ODR_OD7);
			GPIOA->ODR &= ~(GPIO_ODR_OD6);
			GPIOA->ODR &= ~(GPIO_ODR_OD5);
		} else if (g_adc_value > 2460) {
			GPIOB->ODR |= (GPIO_ODR_OD6);
			GPIOA->ODR &= ~(GPIO_ODR_OD7);
			GPIOA->ODR &= ~(GPIO_ODR_OD6);
			GPIOA->ODR &= ~(GPIO_ODR_OD5);
		} else if (g_adc_value > 1640) {
			GPIOB->ODR |= (GPIO_ODR_OD6);
			GPIOA->ODR |= (GPIO_ODR_OD7);
			GPIOA->ODR &= ~(GPIO_ODR_OD6);
			GPIOA->ODR &= ~(GPIO_ODR_OD5);
		} else if (g_adc_value > 820) {
			GPIOB->ODR |= (GPIO_ODR_OD6);
			GPIOA->ODR |= (GPIO_ODR_OD7);
			GPIOA->ODR |= (GPIO_ODR_OD6);
			GPIOA->ODR &= ~(GPIO_ODR_OD5);
		} else {
			GPIOB->ODR |= (GPIO_ODR_OD6);
			GPIOA->ODR |= (GPIO_ODR_OD7);
			GPIOA->ODR |= (GPIO_ODR_OD6);
			GPIOA->ODR |= (GPIO_ODR_OD5);
		}
	}
	return 0;
}
