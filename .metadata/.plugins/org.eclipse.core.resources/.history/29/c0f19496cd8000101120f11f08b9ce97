#include <stdint.h>
#include <stdio.h>
#define STM32F411xE
#include "stm32f4xx.h"

// ฟังก์ชันส่งข้อความแบบ Polling (ง่ายที่สุดสำหรับการทดสอบ)
void uart_tx_string_blocking(const char* str) {
    for (int i = 0; str[i] != '\0'; i++) {
        while (!(USART2->SR & USART_SR_TXE)); // รอจนกว่า Tx buffer จะว่าง
        USART2->DR = str[i];
    }
}

int main(void) {
    // --- 1. เปิด Clock ---
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
    RCC->APB1ENR |= RCC_APB1ENR_USART2EN;
    RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;

    // --- 2. ตั้งค่า GPIO ---
    // Sensor Pin (PA0) -> Analog
    GPIOA->MODER |= (0b11 << GPIO_MODER_MODER0_Pos);
    // UART Pins (PA2-TX, PA3-RX) -> AF7
    GPIOA->MODER |= (0b10 << GPIO_MODER_MODER2_Pos) | (0b10 << GPIO_MODER_MODER3_Pos);
    GPIOA->AFR[0] |= (7 << GPIO_AFRL_AFSEL2_Pos) | (7 << GPIO_AFRL_AFSEL3_Pos);

    // --- 3. ตั้งค่า USART2 (แบบง่าย) ---
    USART2->BRR = 139; // 115200 baud
    USART2->CR1 |= USART_CR1_TE | USART_CR1_RE | USART_CR1_UE;

    // --- 4. ตั้งค่า ADC1 (แบบง่ายที่สุด) ---
    ADC1->SQR1 = 0; // L=0, แปลงค่าแค่ 1 channel
    ADC1->SQR3 = 0; // แปลงค่า Channel 0 เป็นลำดับที่ 1
    ADC1->CR2 |= ADC_CR2_ADON; // เปิด ADC

    // *** เพิ่ม Delay เพื่อรอให้ ADC พร้อมทำงาน (Stabilization Time) ***
    for (volatile int i = 0; i < 1000; i++);

    char buffer[50];

    // --- 5. Main Loop ---
    while (1) {
        ADC1->CR2 |= ADC_CR2_SWSTART; // เริ่มการแปลงค่า
        while (!(ADC1->SR & ADC_SR_EOC)); // รอจนกว่าจะแปลงเสร็จ
        uint16_t raw_adc_value = ADC1->DR; // อ่านค่าดิบ

        // แปลงค่าดิบเป็นข้อความแล้วส่งออก UART
        sprintf(buffer, "RAW ADC (PA0) = %d\r\n", raw_adc_value);
        uart_tx_string_blocking(buffer);

        // หน่วงเวลา 0.5 วินาที
        for (volatile int i = 0; i < 800000; i++);
    }
}
