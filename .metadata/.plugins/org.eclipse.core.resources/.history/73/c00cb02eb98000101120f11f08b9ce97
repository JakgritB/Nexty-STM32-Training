#include <stdint.h>
#define STM32F411xE
#include "stm32f4xx.h"

// Mapping LED pins สำหรับเลข 1-9 (bit = pin)
typedef struct {
    uint32_t set;
    uint32_t reset;
} LED_pattern;

const LED_pattern led_map[10] = {
    {0, 0}, // 0 → all off
    {(1<<5) | (1<<7), (1<<8) | (1<<9) | (1<<10)},         // 1
    {(1<<5) | (1<<8), (1<<7) | (1<<9) | (1<<10)},         // 2
    {(1<<5) | (1<<7) | (1<<8), (1<<9) | (1<<10)},         // 3
    {(1<<5) | (1<<10), (1<<7) | (1<<8) | (1<<9)},         // 4
    {(1<<5) | (1<<7) | (1<<10), (1<<8) | (1<<9)},         // 5
    {(1<<5) | (1<<8) | (1<<10), (1<<7) | (1<<9)},         // 6
    {(1<<5) | (1<<7) | (1<<8) | (1<<10), (1<<9)},         // 7
    {(1<<5) | (1<<9), (1<<7) | (1<<8) | (1<<10)},         // 8
    {(1<<5) | (1<<7) | (1<<10) | (1<<9), (1<<8)},         // 9
};

// ฟังก์ชันรับ byte ผ่าน UART2 (polling)
char vdg_UART_RxByte() {
    while ((USART2->SR & USART_SR_RXNE) == 0)
        ;
    return USART2->DR;
}

// ฟังก์ชันแสดง LED ตามตัวเลข
void display_LED(char num) {
    if(num < '0' || num > '9') num = '0'; // safety
    LED_pattern p = led_map[num - '0'];

    // Reset pins
    if(p.reset & (1<<5)) GPIOA->BSRR = ((1<<5) << 16);
    if(p.reset & (1<<8)) GPIOA->BSRR = ((1<<8) << 16);
    if(p.reset & (1<<9)) GPIOA->BSRR = ((1<<9) << 16);
    if(p.reset & (1<<7)) GPIOC->BSRR = ((1<<7) << 16);
    if(p.reset & (1<<10)) GPIOB->BSRR = ((1<<10) << 16);

    // Set pins
    if(p.set & (1<<5)) GPIOA->BSRR = (1<<5);
    if(p.set & (1<<8)) GPIOA->BSRR = (1<<8);
    if(p.set & (1<<9)) GPIOA->BSRR = (1<<9);
    if(p.set & (1<<7)) GPIOC->BSRR = (1<<7);
    if(p.set & (1<<10)) GPIOB->BSRR = (1<<10);
}

int main(void) {
    // เปิด clock
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN | RCC_AHB1ENR_GPIOBEN | RCC_AHB1ENR_GPIOCEN;
    RCC->APB1ENR |= RCC_APB1ENR_USART2EN;

    // ตั้ง GPIO output (LED)
    GPIOA->MODER |= (0b01 << GPIO_MODER_MODER5_Pos) |
                    (0b01 << GPIO_MODER_MODER8_Pos) |
                    (0b01 << GPIO_MODER_MODER9_Pos);
    GPIOC->MODER |= (0b01 << GPIO_MODER_MODER7_Pos);
    GPIOB->MODER |= (0b01 << GPIO_MODER_MODER10_Pos);

    // ตั้ง PA3 เป็น USART2 RX
    GPIOA->MODER &= ~(0b11 << GPIO_MODER_MODER3_Pos);
    GPIOA->MODER |= (0b10 << GPIO_MODER_MODER3_Pos); // alternate
    GPIOA->AFR[0] &= ~(0xF << GPIO_AFRL_AFSEL3_Pos);
    GPIOA->AFR[0] |= (0x7 << GPIO_AFRL_AFSEL3_Pos); // AF7

    // USART configuration
    USART2->CR1 |= USART_CR1_UE | USART_CR1_RE;
    USART2->BRR = 139; // 115200 baud

    while(1) {
        char received = vdg_UART_RxByte();
        display_LED(received);
    }
}
